----0513오전=================================================================================       
--1. EMPLOYEES 테이블의 구조를 출력
desc employees;

--2. EMPLOYEES 테이블에서 중복되지 않는 부서번호 출력 nulls first
select distinct department_id
from employees
order by department_id nulls first;

--3. 부서가 없는 직원을 출력하라
select *
from employees
where department_id is null;

--4. EMPLOYEES 테이블의 직원의 이름과 업무를 출력
select concat(first_name,last_name),job_id
from employees;


--5. EMPLOYEES 테이블의 직원의 이름과 월급을 출력 단 월급이 5000~10000 사이의 직원
select concat(first_name,last_name) "이름" ,job_id, salary
from employees
where salary between 5000 and 10000
order by salary asc;

select count(employee_id) 직원인원수, sum(salary) 월급합, avg(salary) 평균, stddev(salary) 월급표준편차, variance(salary) 월급분산값
from employees
where salary between 5000 and 10000
order by salary asc;

--6. EMPLOYEES 테이블의  월급이 5000~10000 사이의 직원들의  인원수와 월급합과 평균을 출력
select count(*)"인원수", sum(salary) "월급 총합", round(avg(salary),2) "평균"
from employees
where salary between 5000 and 10000
order by salary asc;

--5. DEPARTMENT 테이블의 구조를 확인하라
desc DEPARTMENTS;

--6. DEPARTMENT 테이블에서 부서명과 위치정보를 출력
select department_name , location_id
from departments;

--7. 입사월 05년 3월~10월인 직원들의 명단을 출력 
select concat(first_name,last_name)"이름",hire_date
from employees
where hire_date between last_day('2005/02/01') and last_day('2005/10/01')
order by hire_date ;


SELECT TO_DATE('20050301','YYYYMMDDHH24MISS') AS DD
FROM DUAL;

SELECT FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE, 'YYYY') = '2005'
AND (
    TO_CHAR(HIRE_DATE, 'MM') BETWEEN '05' AND '10'
    );
    
SELECT FIRST_NAME,HIRE_DATE
FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE, 'YYYY-MM') BETWEEN '2005-05' AND '2005-10';

-- 8. 사원번호가 204번인 직원의 이름과 부서번호 월급을 출력
select concat(first_name,last_name)"이름", department_id, salary
from employees
where employee_id = 204;

-- 9. 부서가 IT를 포함하는 직원의 이름을 출력하시오. ???근데 부서명은 어떻게 출력하지?
select department_id, concat(first_name, concat(' ', last_name))
from employees
where department_id in
    (select department_id
    from departments
    where department_name like '%IT%'
    );

--조인을 쓰면 가능하다. 부서명을 출력할 수 있드아 
SELECT FIRST_NAME || ' ' || LAST_NAME 이름, DEPARTMENTS.DEPARTMENT_NAME
FROM EMPLOYEES
JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
WHERE DEPARTMENTS.DEPARTMENT_NAME LIKE '%IT%';

-- 10. 보너스가 급여보다 10% 이상 많은 모든직원정보를 출력
select * 
from employees
where 
 (salary*12+salary*12*nvl(commission_pct,0))> salary*12+salary*12*0.1;

select (salary*12+ commission_pct*salary),first_name
from employees;
select (salary*12)+(salary*12*0.1)
from employees;
---================================================
WITH ABC(EMPID,NAME,SAL,TOTSAL) AS
(
SELECT TO_CHAR(EMPLOYEE_ID,'L999') EMPID, 
        FIRST_NAME || ' ' || LAST_NAME NAME , 
        (SALARY*12),
       -- TO_NUMBER(SALARY*12,'L999,999,999,999') DD ,   
       (SALARY*12 + SALARY * 12 * NVL(COMMISSION_PCT,0)) TOTSAL
FROM EMPLOYEES
)
SELECT * FROM ABC
WHERE TOTSAL/SAL >= 1.1;

--11. 직원이름, 부서번호, 월급, 등급
--    월급이 1000~5000 : C 등급
--    월급이 5000~12000 : B 등급
--    월급이 12000~ : A 등
    
    select first_name, department_id, salary ,' ' ||
        case 
        when salary between 1000 and 5000 then 'c등급'
        when salary between 5000 and 12000 then 'b등급'
        when salary >= 12000 then 'a등급'
        ELSE 'N/A' 
        END as "굿잡은영쓰" from employees;
----0513오후=================================================================================        
--JOIN 설명
--다른 테이블에 있는 칼럼들을 모아서 새로운 테이블에 표현한다.

SELECT COUNT(*) FROM EMPLOYEES; --108개
SELECT COUNT(*) FROM DEPARTMENTS; --27개

--CARTISAN PRODUCT : CROSS JOIN
SELECT FIRST_NAME, DEPARTMENT_NAME      -- 108*27,, 1: N 대응 
FROM EMPLOYEES, DEPARTMENTS;        --2943개 일종의 CARTISAN PRODUCT임. 
--그러니깐 EMPLOYEES에서 직원이름 전부다 가져오고 DEPARTMENTS 에서 1가지 직종을 다 대입시킴, 그걸 반복 

--조건을 대입시킨다.
-- = 양쪽 다 존재해야 출력, 공통되는 부분만 추출 : INNER JOIN 교집합 
SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
--위에는 과거,밑에는 현재// 둘다 INNER JOIN 
SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES INNER JOIN DEPARTMENTS
ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID; --106개

--108명 전체출력 (+)를 붙이면 NULL값도 출력
SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+);
--NULL이 오른쪽에 있으니깐 LEFT OUTER JOIN 
--NULL이 왼쪽에 있으면 RIGTH OUTER JOIN 

SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES LEFT OUTER JOIN DEPARTMENTS
ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
--핵심은 LEFT 인지 RIGHT인지  LEFT 인 경우 EMPLOYYES 다 찍어놓고, 공통된 DEPARTMENTS의 정보를 가져다가 붙임

SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID ;          -122

SELECT COUNT(DEPARTMENT_ID) FROM DEPARTMENTS;  --27
SELECT COUNT(DEPARTMENT_ID) FROM EMPLOYEES;     --106
SELECT COUNT(DISTINCT DEPARTMENT_ID) FROM EMPLOYEES;    --11개

--FULL OUTER JOIN       --124개 양쪽에 존재하는 데이터 전부 출력 
SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E FULL OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID ;          

--부서이름, 도시명, 거리명
--DEPARTMENT_NAME , CITY , STREET_ADDRESS
SELECT COUNT(*) FROM DEPARTMENTS;
SELECT COUNT(*) FROM LOCATIONS;

SELECT D.DEPARTMENT_NAME,L.CITY,L.STREET_ADDRESS
FROM DEPARTMENTS D , LOCATIONS L
WHERE D.LOCATION_ID = L.LOCATION_ID;

--INNER JOIN
SELECT D.DEPARTMENT_NAME,L.CITY,L.STREET_ADDRESS
FROM DEPARTMENTS D INNER JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID;

SELECT D.DEPARTMENT_NAME,L.CITY,L.STREET_ADDRESS
FROM DEPARTMENTS D JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID;

SELECT D.DEPARTMENT_NAME,L.CITY,L.STREET_ADDRESS
FROM DEPARTMENTS D LEFT JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID;

SELECT D.DEPARTMENT_NAME,  L.CITY,  L.STREET_ADDRESS
FROM DEPARTMENTS D RIGHT JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID 
ORDER BY DEPARTMENT_NAME NULLS FIRST;
--이건 RIGHT 니깐 LOCATIONS에다가 DEPARTMENTS를 붙인다.

SELECT D.DEPARTMENT_NAME,L.CITY,L.STREET_ADDRESS
FROM DEPARTMENTS D FULL JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID;


DESC DEPARTMENTS;
DESC LOCATIONS;

----------------------------------------------------------------
GROUP BY 추가예제
ROLLUP()

CUBE()

--부서별 월급합 : GROUP BY 
--기준에 따라서 집계되는것이 다르다.
SELECT DEPARTMENT_ID ,JOB_ID , SUM(SALARY) 
 FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID
ORDER BY DEPARTMENT_ID;
--DEPARTMENT별 SUB토탈뿌려주고 JOB_ID별로 SUB토탈 뿌려줌(밑에 4) 
--즉 DEPARTMENT_ID의 소합계 + JOB_ID의 소합계 
SELECT DEPARTMENT_ID ,JOB_ID , SUM(SALARY) 
 FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID)
ORDER BY DEPARTMENT_ID;
--  이건 DEPARTMENT_ID의 소집계만 있다.즉 DEPARTMENT_ID 20번에 해당하는걸 전부다 묶는다
SELECT DEPARTMENT_ID ,JOB_ID , SUM(SALARY) 
 FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, ROLLUP(JOB_ID)
ORDER BY DEPARTMENT_ID;
--이건 JOB ID 에 대한 소집계만 있다.
SELECT DEPARTMENT_ID ,JOB_ID , SUM(SALARY) 
 FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID), JOB_ID
ORDER BY DEPARTMENT_ID;

DESC EMPLOYEES;

1.입사한 지 15년 차인 사람들의 명단
SELECT FIRST_NAME || ' ' || LAST_NAME ,HIRE_DATE
FROM EMPLOYEES
WHERE TO_CHAR(SYSDATE,'YY')-TO_CHAR(HIRE_DATE,'YY')=15;

2.입사한 지 15년 차인 사람들의 월급 평균
SELECT ROUND(AVG(SALARY),2)
FROM EMPLOYEES
WHERE TO_CHAR(SYSDATE,'YY')-TO_CHAR(HIRE_DATE,'YY')=15;

3.부서별 월급 평균 출력
SELECT  DEPARTMENTS.DEPARTMENT_NAME, ROUND(AVG(SALARY),2)
FROM EMPLOYEES
JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
GROUP BY DEPARTMENTS.DEPARTMENT_NAME;

4. IT부서의 월급 평균을 구하라
SELECT DEPARTMENTS.DEPARTMENT_NAME, ROUND(AVG(SALARY),2)
FROM EMPLOYEES
JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
WHERE DEPARTMENTS.DEPARTMENT_NAME LIKE 'IT'
GROUP BY DEPARTMENTS.DEPARTMENT_NAME;

5.미국에 있는 부서의 이름 CONTRY를 거쳐서 -> LOCATION ID - > DEPARTMENT ID 

6. 영국에 있는 부서의 CITY, POSTAL_CODE 출력
SELECT LOCATIONS.CITY, LOCATIONS.POSTAL_CODE
FROM LOCATIONS
JOIN COUNTRIES ON LOCATIONS.COUNTRY_ID = COUNTRIES.COUNTRY_ID
WHERE LOCATIONS.COUNTRY_ID = 'UK';

7.'Neena'의 Job History를 날짜별로 출력
SELECT E.EMPLOYEE_ID, H.EMPLOYEE_ID, H.START_DATE, H.END_DATE
FROM EMPLOYEES E,
     JOB_HISTROY H
JOIN EMPLOYEES ON E.EMPLOYEE_ID = H.EMPLOYEE_ID
WHERE E.FIRST_NAME='Neena';




8. AC_ACCOUNT의 최대월급과 최소월급을 출력


9. IT부서의 매니저 이름을 출력

10 .JOB이 IT인 직원 평균월급보다 월급이 많은 직원명단
---------선생님---------
1.입사한 지 15년 차인 사람들의 명단
SELECT EMPLOYEE_ID, FIRST_NAME, TRUNC(MONTHS_BETWEEN(SYSDATE,HIRE_DATE)/12,0)
FROM EMPLOYEES
WHERE TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)/12,0) = 15;

2.부서별로 입사한 지 15년 차인 사람들의 월급 평균
SELECT AVG(SALARY) 월급평균
FROM EMPLOYEES
WHERE TRUNC(MONTHS_BETWEEN(SYSDATE , HIRE_DATE) / 12) = 15;

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2) 월급평균, TO_CHAR(AVG(SALARY), 'L999,999.99') 월급평균
FROM EMPLOYEES
WHERE TRUNC(MONTHS_BETWEEN(SYSDATE,HIRE_DATE)/12)=15
GROUP BY DEPARTMENT_ID;

3.부서별 월급 평균 출력

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY 1;

4. IT부서의 월급 평균을 구하라
SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2)
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60
GROUP BY DEPARTMENT_ID
ORDER BY 1;

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2)
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (
    SELECT DEPARTMENT_ID FROM DEPARTMENTS
    WHERE DEPARTMENT_NAME = 'IT'
    )
GROUP BY DEPARTMENT_ID
ORDER BY 1;

5.미국에 있는 부서의 이름 (United States of America)
SELECT COUNTRY_NAME, L.CITY, D.DEPARTMENT_NAME
FROM COUNTRIES C, LOCATIONS L, DEPARTMENTS D
WHERE C.COUNTRY_ID = L.COUNTRY_ID
AND L.LOCATION_ID = D.LOCATION_ID
AND COUNTRY_NAME = 'United States of America';

SELECT COUNTRY_NAME, L.CITY, D.DEPARTMENT_NAME
FROM COUNTRIES C
    JOIN LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
    JOIN DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
WHERE C.COUNTRY_NAME = 'United States of America';

5.1 미국에 근무하는 직원의 이름과 월급평균을 구하시오
먼저 조인하고, 집계함수 날려서 월급의 평균을 구해. 
컨트리 로케이션
디팔트먼트 인플로이 



6. 영국에 있는 부서의 CITY, POSTAL_CODE 출력
SELECT LOCATIONS.CITY, LOCATIONS.POSTAL_CODE
FROM LOCATIONS
JOIN COUNTRIES ON LOCATIONS.COUNTRY_ID = COUNTRIES.COUNTRY_ID
WHERE LOCATIONS.COUNTRY_ID = 'UK';

SELECT C.COUNTRY_NAME, L.CITY, L.POSTAL_CODE
FROM COUNTRIES C, LOCATIONS L 
WHERE C.COUNTRY_ID = L.COUNTRY_ID
AND c.country_name = 'United Kingdom' ;

7.'Neena'의 Job History를 날짜별로 출력
SELECT E.EMPLOYEE_ID, H.EMPLOYEE_ID, H.START_DATE, H.END_DATE
FROM EMPLOYEES E,
     JOB_HISTROY H
JOIN EMPLOYEES ON E.EMPLOYEE_ID = H.EMPLOYEE_ID
WHERE E.FIRST_NAME='Neena';




8. AC_ACCOUNT의 최대월급과 최소월급을 출력


9. IT부서의 매니저 이름을 출력

10 .JOB이 IT인 직원 평균월급보다 월급이 많은 직원명단


---5/14 오전------------------------------------------------------------------
조인 : 여러 칼럼에있는것을 새로운 표로 만드는 경우 
서브쿼리 : 하나에 있는 결과로 다른것을  

cross join (=cartesian product)는 A테이블에 3개 컬럼 B테이블에 3개 컬럼인 경우 3*3 의 테이블을 새로 만든다.
(INNER) JOIN = JOIN 공통적인 부분만 가져온다  // LEFT (OUT JOIN) = LEFT 

 --JOIN정리
 SELECT * FROM EMPLOYEES;
 SELECT COUNT(*) FROM EMPLOYEES; --108개
 SELECT COUNT(DEPARTMENT_ID) FROM EMPLOYEES; --106개 NULL값 2개 
 SELECT * FROM DEPARTMENTS;
 SELECT COUNT(*) FROM DEPARTMENTS;  --27개
 
 --이게  CROSS JOIN // 108 * 27개 
 SELECT FIRST_NAME || ' ' || LAST_NAME, DEPARTMENT_NAME
 FROM EMPLOYEES , DEPARTMENTS;
  --106개 (공통된거만 출력함 , NULL은 출력안하는거지 )  
 SELECT FIRST_NAME || ' ' || LAST_NAME ㅋㅋ, DEPARTMENT_NAME
 FROM EMPLOYEES E, DEPARTMENTS D 
 WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 ORDER BY FIRST_NAME || ' ' || LAST_NAME ASC;
  --ORDER BY 1;
  
  --inner 조인방식  106개 (공통된거만 출력함 , NULL은 출력안하는거지 )  
SELECT E.FIRST_NAME || ' ' || E.LAST_NAME, D.DEPARTMENT_NAME
 FROM EMPLOYEES E
 JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
 --부서정보가 없는 직원 (지은,Kimberely)이 빠지게 된다. 2개 
 SELECT *
 FROM EMPLOYEES E
 WHERE E.DEPARTMENT_ID IS NULL;
 
 --108명을 모두 출력하시오 (이름은 다 찍고, 부서명이 NULL이 없어도 출력)( left outer join)
 SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
 FROM EMPLOYEES E, DEPARTMENTS D 
 WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
 ORDER BY 1;
 --108명을 모두 출력하시오 (이름은 다 찍고, 부서명이 NULL이 없어도 출력)( left outer join)
 --A가 부서 명 의 null+부서명 이고 교집합이 이름+부서명이고(null제외) B가 이름 
 SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
 FROM EMPLOYEES E
 LEFT JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
  
  --모든 부서정보를 출력
  --직원이 근무하는 부서는 직원명도 같이 출력 -- NULL값인 지은이는 안나옴 
  -- 총 122개의 자료이며 , 지은, KIMBVERRY 는 출력안 
  --모든 부서수 27 , 전체직원수 108개 , NULL값 2개
  -- 직원이 근무하는 부서수 11
  -- 122 = 27 - 11 + 106
    
   --모든 부서와 모든 직원명을 출력해라  : 122+ 2
   SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, E.FIRST_NAME
  FROM DEPARTMENTS D FULL OUTER JOIN EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
  ORDER BY D.DEPARTMENT_ID;
  
 1) 전체부서정보
 SELECT * FROM DEPARTMENTS;
 2) 직원이 근무하는 부서 번호 - 근무중인 11개 부서 
 SELECT DISTINCT DEPARTMENT_ID
 FROM EMPLOYEES;
 3) 직원이 근무하는 부서번호 
  3-1) 근무중인 11개 부서
  SELECT DISTINCT DEPARTMENT_ID
  FROM EMPLOYEES;
  3-2) 전체 부서 번호
  SELECT DEPARTMENT_ID
  FROM DEPARTMENTS;
  3-3)
  SELECT DEPARTMENT_ID ,DEPARTMENT_NAME
  FROM DEPARTMENTS
  WHERE DEPARTMENT_ID = ( 
  SELECT DISTINCT DEPARTMENT_ID
  FROM EMPLOYEES);
--ORA-01427: single-row subquery returns more than one row 에러메세지
--이유는 위에 = 는 1개를 받기때문에 오류메세지가 뜬다.
  SELECT DEPARTMENT_ID ,DEPARTMENT_NAME
  FROM DEPARTMENTS
  WHERE DEPARTMENT_ID IN ( 
  SELECT DISTINCT DEPARTMENT_ID
  FROM EMPLOYEES);
  
  --직원이 근무하지 않는 부서명  
  SELECT DEPARTMENT_ID ,DEPARTMENT_NAME
  FROM DEPARTMENTS
  WHERE DEPARTMENT_ID NOT IN ( 
  SELECT DISTINCT DEPARTMENT_ID
  FROM EMPLOYEES
  WHERE DEPARTMENT_ID IS NOT NULL
  );
 --직원이 근무하는 부서정보(join)
SELECT DISTINCT D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY D.DEPARTMENT_ID;

SELECT DISTINCT D.DEPARTMENT_ID , D.DEPARTMENT_NAME
FROM DEPARTMENTS D
JOIN EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID;
 --직원이 근무하지 않는 부서정보
 SELECT DISTINCT D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY D.DEPARTMENT_ID;
 
  --SELF JOIN 
  --EMPLOYEES TABLE의 EMPLOYEE_ID (직원번호)
  --EMPLOYEES TABLE의 MANAGER_ID (상사번호)를 출력해봐라 
  
  --직원 이름, 상사이름
    SELECT E1.EMPLOYEE_ID,
    E1.FIRST_NAME || ' ' || E1.LAST_NAME 상사이름,
    E2.FIRST_NAME || ' ' || E2.LAST_NAME 직원이름
    FROM EMPLOYEES E1
    JOIN EMPLOYEES E2
    ON E1.EMPLOYEE_ID = E2.MANAGER_ID;
    
    SELECT E1.EMPLOYEE_ID,
    E1.FIRST_NAME || ' ' || E1.LAST_NAME 상사이름,
    E2.FIRST_NAME || ' ' || E2.LAST_NAME 직원이름
    FROM EMPLOYEES E1, EMPLOYEES E2
    WHERE E1.EMPLOYEE_ID = E2.MANAGER_ID
    ORDER BY E1.EMPLOYEE_ID;
    
    NATURAL JOIN - ON 조건이 없어도 자동으로 조건을 만든다. 
    
    SELECT E.EMPLOYEE_ID, D.DEPARTMENT_NAME
    FROM EMPLOYEES E JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
  ----------------
  --비등가 조인 : NON - EQUIVALANCE JOIN - JOIN조건이 == 이 아닌것
  CREATE TABLE SALGRADE
  (
    GRADE VARCHAR2(1) PRIMARY KEY,
    MINSAL NUMBER(8,2),
    MAXSAL NUMBER(8,2)
  );
  SELECT * FROM SALGRADE;
  DROP TABLE SALGRADE;
  
  
  INSERT INTO SALGRADE ( GRADE, MINSAL, MAXSAL)
  VALUES ( 'A' , 15000, 100000);
  INSERT INTO SALGRADE ( GRADE, MINSAL, MAXSAL)
  VALUES ( 'B' , 10000, 14999);
  INSERT INTO SALGRADE ( GRADE, MINSAL, MAXSAL)
  VALUES ( 'C' , 5000, 9999);
  INSERT INTO SALGRADE ( GRADE, MINSAL, MAXSAL)
  VALUES ( 'D' , 1000, 4999);
  INSERT INTO SALGRADE ( GRADE, MINSAL, MAXSAL)
  VALUES ( 'E' , 0, 999);
  
  SELECT *
  FROM  EMPLOYEES E  JOIN SALGRADE S  ON E.SALARY BETWEEN S.MINSAL AND S.MAXSAL
    ORDER BY SALARY DESC;
    
    
1) job_id 별 인원수
SELECT JOB_ID ,COUNT(JOB_ID)
FROM EMPLOYEES
GROUP BY ROLLUP (JOB_ID) ;

2) 부서명 부서위치(도로명, 도시명, 주 이름)
SELECT D.DEPARTMENT_NAME, L.CITY, L.COUNTRY_ID, L.STREET_ADDRESS
FROM LOCATIONS L
JOIN DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID;

3) 부서명, 도시명, 국가명
SELECT D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME
FROM COUNTRIES C
     JOIN LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
    JOIN DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID;

4) 직원명, 부서명, 부서위치(?)   
SELECT E.FIRST_NAME || ' ' || E.LAST_NAME, D.DEPARTMENT_NAME, L.CITY
FROM DEPARTMENTS D
JOIN EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN LOCATIONS L ON L.LOCATION_ID = D.LOCATION_ID;

5) 직원명, 부서명, 부서위치,국가명
    미국에 위치한 부서 별 직원의 월급평균.
SELECT D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME, ROUND(AVG(SALARY),2)
FROM DEPARTMENTS D
JOIN EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN LOCATIONS L ON L.LOCATION_ID = D.LOCATION_ID
JOIN COUNTRIES C ON C.COUNTRY_ID = L.COUNTRY_ID
WHERE C.COUNTRY_NAME = 'United States of America'
GROUP BY D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME,D.DEPARTMENT_NAME;

6) 부서별 월급합
SELECT D.DEPARTMENT_NAME,SUM(SALARY)
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY ROLLUP(DEPARTMENT_NAME);

7) 직원 이름, 상사이름을 출력, NULL 포함 ??? 
    SELECT E1.EMPLOYEE_ID, 
    E1.FIRST_NAME || ' ' || E1.LAST_NAME 상사이름,
    E2.FIRST_NAME || ' ' || E2.LAST_NAME 직원이름
    FROM EMPLOYEES E1, EMPLOYEES E2
    WHERE E1.EMPLOYEE_ID = E2.EMPLOYEE_ID
    OR E1.EMPLOYEE_ID IS NULL
    OR E2.EMPLOYEE_ID IS NULL
    ;
    
    SELECT E1.EMPLOYEE_ID,
    E1.FIRST_NAME || ' ' || E1.LAST_NAME 상사이름,
    E2.FIRST_NAME || ' ' || E2.LAST_NAME 직원이름
    FROM EMPLOYEES E1, EMPLOYEES E2
    WHERE E1.EMPLOYEE_ID = E2.MANAGER_ID
    ORDER BY E1.EMPLOYEE_ID;

8) 직원의 업무시작날자 종료일, 부서명 출력 출력
   추가) 단 it와 shipping 부서만 출력.
   SELECT FIRST_NAME, START_DATE, END_DATE ,DEPARTMENT_NAME
   FROM EMPLOYEES E
   JOIN JOB_HISTORY H ON E.DEPARTMENT_ID = H.DEPARTMENT_ID
   JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = H.DEPARTMENT_ID
   WHERE D.DEPARTMENT_ID IN (60,50);
   
9) 직원의 업무시작날자 종료일, 부서명 출력
ALTER SESSION SET NLS_DATE_FORMAT='YYYY/MM/DD HH24:MI:SS';
SELECT SYSDATE FROM DUAL;

   9-1) 시작일이 06년 03월인 직원의 정보 출력
   SELECT FIRST_NAME, START_DATE, END_DATE ,DEPARTMENT_NAME
   FROM EMPLOYEES E
   JOIN JOB_HISTORY H ON E.DEPARTMENT_ID = H.DEPARTMENT_ID
   JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = H.DEPARTMENT_ID
   WHERE H.START_DATE LIKE '2006/03%';
   
   9-2) 종료일이 07년 12월 31일인 직원의 정보 출력
   SELECT FIRST_NAME, START_DATE, END_DATE ,DEPARTMENT_NAME
   FROM EMPLOYEES E
   JOIN JOB_HISTORY H ON E.DEPARTMENT_ID = H.DEPARTMENT_ID
   JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = H.DEPARTMENT_ID
   WHERE H.END_DATE LIKE '2007/12/31 00:00:00';
   
   9-3) 근무지역이 영국
   SELECT FIRST_NAME, START_DATE, END_DATE ,DEPARTMENT_NAME, C.COUNTRY_NAME
   FROM EMPLOYEES E
   JOIN JOB_HISTORY H ON E.DEPARTMENT_ID = H.DEPARTMENT_ID
   JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = H.DEPARTMENT_ID
   JOIN LOCATIONS L ON L.LOCATION_ID = D.LOCATION_ID
   JOIN COUNTRIES C ON C.COUNTRY_ID = L.COUNTRY_ID
   WHERE C.COUNTRY_ID = 'UK';
   
10) 업무시작 일별,월별 인원수(*) (???)
SELECT COUNT(*),TO_CHAR(START_DATE,'YYYY'),TO_CHAR(START_DATE,'MM')
FROM JOB_HISTORY H
JOIN EMPLOYEES E ON E.EMPLOYEE_ID = H.EMPLOYEE_ID
WHERE START_DATE >='1999/01/01' AND START_DATE<'2020/12/31'
GROUP BY TO_CHAR(START_DATE,'YYYY'),TO_CHAR(START_DATE,'MM');


11) job_history 2건 이상이 등록된 직원(???)
SELECT JH.EMPLOYEE_ID,  E.FIRST_NAME || ' ' || E.LAST_NAME 직원명, COUNT(JH.EMPLOYEE_ID)
FROM EMPLOYEES E
JOIN JOB_HISTORY JH
ON E.EMPLOYEE_ID = JH.EMPLOYEE_ID
GROUP BY JH.EMPLOYEE_ID, E.FIRST_NAME || ' ' || E.LAST_NAME
HAVING COUNT(JH.EMPLOYEE_ID) >= 2;

12) 최대 월급을 받는 사람의 이름과 최소 월급을 받는 사람의 이름
SELECT *
FROM 
(
SELECT *
FROM EMPLOYEES
ORDER BY SALARY ASC) 
WHERE SALARY IS NOT NULL AND ROWNUM=1

UNION

SELECT *
FROM 
(SELECT *
FROM EMPLOYEES
ORDER BY SALARY DESC)
WHERE SALARY IS NOT NULL AND ROWNUM=1;

13) daniel 과 같은 부서에 근무하는 사람들
SELECT employee_id
FROM EMPLOYEES
WHERE first_name = 'Daniel'; --109번

SELECT FIRST_NAME,JOB_ID,DEPARTMENT_ID
FROM (
SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 100
OR JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 109)
);


14) 'Bruce'가 속해있는 부서명
SELECT employee_id,DEPARTMENT_ID
FROM EMPLOYEES
WHERE first_name = 'Bruce'; 

SELECT FIRST_NAME,JOB_ID,DEPARTMENT_ID
FROM (
SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60
OR JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 104)
);
   
   
   
   -------============선생님
   
   
 SELECT * FROM JOBS;
   
1) job_id 별 인원수
SELECT E.JOB_ID ,COUNT(JOB_ID)
FROM EMPLOYEES E
GROUP BY E.JOB_ID
ORDER BY E.JOB_ID;
1-2) 모든 업무(JOBS.JOB_ID) 에 대하여 직원수를 출력해봐라(즉 JOBS는 기본키니깐 NULL일수는 없지만 EMPLOYEES는 NULL값도 있을수가 있으니깐 +도 해줘야함 
SELECT J.JOB_ID, COUNT(E.EMPLOYEE_ID) EMPCNT
FROM JOBS J, EMPLOYEES E
WHERE J.JOB_ID = E.JOB_ID(+)
GROUP BY J.JOB_ID;

2) 부서명 부서위치(도로명, 도시명, 주 이름)
SELECT D.DEPARTMENT_NAME 부서명 ,
       L.STREET_ADDRESS || ' ' || L.CITY || ' ' || L.STATE_PROVINCE 부서위치
FROM LOCATIONS L, DEPARTMENTS D
WHERE D.LOCATION_ID = L.LOCATION_ID;

2-1) 직원이 근무하는 부서명, 부서위치(도로명,도시명, 주 이름)
SELECT E.EMPLOYEE_ID, D.DEPARTMENT_NAME 부서명 ,
       L.STREET_ADDRESS || ' ' || L.CITY || ' ' || L.STATE_PROVINCE 부서위치
FROM LOCATIONS L, DEPARTMENTS D, EMPLOYEES E
WHERE D.LOCATION_ID = L.LOCATION_ID
AND D.DEPARTMENT_ID = E.DEPARTMENT_ID;

2-2) 위의 조건으로 전 직원의 정보를 조회해라 
       


3) 부서명, 도시명, 국가명
SELECT D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME
FROM COUNTRIES C
     JOIN LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID --FULL
     JOIN DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID; --FULL
     
     SELECT D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME
     FROM COUNTRIES C
     FULL JOIN LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID --FULL
     FULL JOIN DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID; --FULL
     
SELECT D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME
FROM DEPARTMENTS D
     FULL JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID --FULL
     FULL JOIN COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID; --FULL  

     
SELECT D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME
FROM DEPARTMENTS D
     LEFT JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID --FULL
     LEFT JOIN COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID; --FULL

SELECT D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME
FROM DEPARTMENTS D
     RIGHT JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID --FULL
     RIGHT JOIN COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID; --FULL
     
    
    SELECT * FROM DEPARTMENTS;--27
    SELECT * FROM LOCATIONS;--23
    SELECT * FROM COUNTRIES;--25
    
    LEFT , RIGHT OUTER은 NULL없는쪽이 기준이 된다. 

4) 직원명, 부서명, 부서위치(?)   
SELECT E.FIRST_NAME 직원명, D.DEPARTMENT_NAME 부서명, L.STREET_ADDRESS|| ' ' || L.CITY 부서위치
FROM EMPLOYEES E
LEFT JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
LEFT JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID;

5) 직원명, 부서명, 부서위치,국가명
  
SELECT E.FIRST_NAME 직원명, D.DEPARTMENT_NAME 부서명, L.STREET_ADDRESS|| ' ' || L.CITY 부서위치
FROM EMPLOYEES E
LEFT JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
LEFT JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
LEFT JOIN COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID;
      
5-2) 미국에 위치한 부서 별 직원의 월급평균.
SELECT C.COUNTRY_NAME 국가, D.DEPARTMENT_NAME 부서명, ROUND(AVG(SALARY),2)
FROM COUNTRIES C
JOIN LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
JOIN DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
JOIN EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE C.COUNTRY_NAME = 'United States of America'
GROUP BY C.COUNTRY_NAME, D.DEPARTMENT_NAME
ORDER BY 1,2;


GROUP BY D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME,D.DEPARTMENT_NAME;

6) 부서별 월급합
SELECT D.DEPARTMENT_NAME,SUM(SALARY)
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY ROLLUP(DEPARTMENT_NAME);

7) 직원 이름, 상사이름을 출력, NULL 포함 ??? 
   SELECT E2.FIRST_NAME , E1.FIRST_NAME
   FROM EMPLOYEES E1, EMPLOYEES E2
   WHERE E1.EMPLOYEE_ID(+) = E2.MANAGER_ID; --NULL값도 추가해라 
   
   SELECT D.DEPARTMENT_NAME , E.FIRST_NAME
   FROM EMPLOYEES E, DEPARTMENTS D
   WHERE E.EMPLOYEE_ID = D.DEPARTMENT_ID; --이게 출력이 된다고 모두가 정답이 아니다,, 출력이 정답이 아니라 맞는지 틀렸는지 어떻게 검증할 것인지. 
   
   SELECT D.DEPARTMENT_NAME ,D.DEPARTMENT_ID, E.DEPARTMENT_ID, E.EMPLOYEE_ID, E.FIRST_NAME
   FROM EMPLOYEES E, DEPARTMENTS D
   WHERE E.EMPLOYEE_ID = D.DEPARTMENT_ID;
   
   ---------------------
   
   --8) 직원의 업무시작날짜, 종료일, 부서명 출력  
SELECT JH.START_DATE, JH.END_DATE, D.DEPARTMENT_NAME, E.EMPLOYEE_ID
FROM JOB_HISTORY JH 
JOIN DEPARTMENTS D
ON JH.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN EMPLOYEES E
ON JH.EMPLOYEE_ID = E.EMPLOYEE_ID;

--   추가) 단 it와 shipping 부서만 출력.
SELECT JH.START_DATE, JH.END_DATE, D.DEPARTMENT_NAME, E.EMPLOYEE_ID
FROM JOB_HISTORY JH 
JOIN DEPARTMENTS D
ON JH.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN EMPLOYEES E
ON JH.EMPLOYEE_ID = E.EMPLOYEE_ID
WHERE D.DEPARTMENT_NAME IN('IT', 'Shipping');


SELECT EMPLOYEE_ID, DEPARTMENT_NAME
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
        
               
SELECT E.FIRST_NAME || ' ' || E.LAST_NAME AS NAME, JH.START_DATE, JH.END_DATE, D.DEPARTMENT_NAME,
D.DEPARTMENT_ID
FROM JOB_HISTORY JH JOIN DEPARTMENTS D ON JH.DEPARTMENT_ID = D.DEPARTMENT_ID
               JOIN EMPLOYEES E ON JH.EMPLOYEE_ID = E.EMPLOYEE_ID
ORDER BY NAME;

SELECT E.FIRST_NAME || ' ' || E.LAST_NAME AS NAME, JH.START_DATE, JH.END_DATE, D.DEPARTMENT_NAME,
D.DEPARTMENT_ID
FROM JOB_HISTORY JH JOIN EMPLOYEES E ON JH.EMPLOYEE_ID = E.EMPLOYEE_ID
               JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY NAME;
               
SELECT E.FIRST_NAME || ' ' || E.LAST_NAME AS NAME, JH.START_DATE, JH.END_DATE, D.DEPARTMENT_NAME
FROM DEPARTMENTS D JOIN EMPLOYEES E ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
               JOIN JOB_HISTORY JH ON JH.EMPLOYEE_ID = E.EMPLOYEE_ID
WHERE D.DEPARTMENT_NAME IN ('IT', 'Shipping');
               
SELECT E.FIRST_NAME || ' ' || E.LAST_NAME AS NAME, JH.START_DATE, JH.END_DATE, D.DEPARTMENT_NAME
FROM DEPARTMENTS D JOIN JOB_HISTORY JH ON JH.DEPARTMENT_ID = D.DEPARTMENT_ID
                  JOIN EMPLOYEES E ON E.EMPLOYEE_ID = JH.EMPLOYEE_ID
WHERE D.DEPARTMENT_NAME IN ('IT', 'Shipping');

SELECT E.FIRST_NAME || ' ' || E.LAST_NAME AS NAME, JH.START_DATE, JH.END_DATE, D.DEPARTMENT_NAME
FROM DEPARTMENTS D JOIN JOB_HISTORY JH ON JH.DEPARTMENT_ID = D.DEPARTMENT_ID
                  JOIN EMPLOYEES E ON E.EMPLOYEE_ID = JH.EMPLOYEE_ID
WHERE D.DEPARTMENT_NAME IN ('IT', 'Shipping');
---------------------=====================================
   

   
   

8) 직원의 업무시작날자 종료일, 부서명 출력 출력
   추가) 단 it와 shipping 부서만 출력.
   
   SELECT D.DEPARTMENT_NAME AS 부서명, E.EMPLOYEE_ID AS 직원ID, E.FIRST_NAME || ' ' || E.LAST_NAME AS 직원명,
   J.JOB_TITLE AS 업무명, NVL(JH.START_DATE, E.HIRE_DATE) AS "업무 시작 날짜", 
     --방법 1.  ( 기준데이터, NULL이면, '재직중' 출력, 아니라면 END_DATE출력 )  -- 이건 날짜 형식을 유지하고  
     --DECODE(JH.END_DATE, NULL, '재직중', JH.END_DATE) AS ED  
     --방법 2. 이건 데이터 형식으로 바꾸네 
     CASE
        WHEN JH.END_DATE IS NULL THEN '재직중'
        WHEN JH.END_DATE IS NOT NULL THEN TO_CHAR(JH.END_DATE)
     END 종료일
     
   FROM DEPARTMENTS D, EMPLOYEES E, JOBS J, JOB_HISTORY JH
   WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID(+)
   AND E.JOB_ID = J.JOB_ID(+)
   AND J.JOB_ID = JH.JOB_ID(+)
   ORDER BY E.EMPLOYEE_ID;
   
   문제점 : EMPLOYEES 와 DEPARTMENTS JOB_HISTORY의 해석의 문제가 발생한다.
   직원의 업무시작날짜 , 종료일 부서명을 출력하는데 EMPLOYEES로만 사용하면 현재에 관한 내용
   다른업무 다른직책을 했던 경력을 JOB히스토리에 저장되어있다.
   최종적으로 한 사람의 업무적인 부분을 다 뽑아내려면 두 테이블을 연계하려면 , 
   직원과 업무 경력을 조인해서 ,다른 조인을 해야한다.
   
   EMPLOYEES 는 현재 JOB_ID
   JOB_HISTORY는 과거의 JOB_ID
   
   SELECT E.EMPLOYEE_ID 직원번호, E.FIRST_NAME 이름, 
            JH.START_DATE 시작일
   FROM EMPLOYEES E, JOB_HISTORY JH
   WHERE E.EMPLOYEE_ID = JH.EMPLOYEE_ID ;
   1.여기서 조인을 하면 101번이 2개가 나와버린다.
   이유는 EMPLOYYES의 101번과 JOB_HISTORY의 101번(2개)이 공통되는 부분만 나옴
   
   과정1)
   SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.HIRE_DATE, NULL
   FROM EMPLOYEES E
   과정2)
   SELECT JH.EMPLOYEE_ID, E.FIRST_NAME, JH.START_DATE, JH.END_DATE
   FROM JOB_HISTORY JH, EMPLOYEES E
   WHERE E.EMPLOYEE_ID = JH.EMPLOYEE_ID
   과정3) Neena가 3개가 나옴 (이제 여기서 )
   SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.HIRE_DATE, NULL
   FROM EMPLOYEES E
   UNION
   SELECT JH.EMPLOYEE_ID, E.FIRST_NAME, JH.START_DATE, JH.END_DATE
   FROM JOB_HISTORY JH, EMPLOYEES E
   WHERE E.EMPLOYEE_ID = JH.EMPLOYEE_ID
   과정4) END_DATE에서 오류가 발생한다. DATE 타입인데 CHAR넣으려고 하니깐 안됌.
   WITH ABC( EMP_ID ,FIRST_NAME , START_DATE, END_DATE)
   AS 
    (
     SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.HIRE_DATE, NULL
   FROM EMPLOYEES E
   UNION
   SELECT JH.EMPLOYEE_ID, E.FIRST_NAME, JH.START_DATE, JH.END_DATE
   FROM JOB_HISTORY JH, EMPLOYEES E
   WHERE E.EMPLOYEE_ID = JH.EMPLOYEE_ID
     )
     SELECT EMP_ID ,FIRST_NAME , START_DATE, NVL(END_DATE,'재직중')
     FROM ABC;
     
   과정5)   
   WITH ABC( EMP_ID ,FIRST_NAME , START_DATE, END_DATE)
   AS 
    (
     SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.HIRE_DATE, NULL
   FROM EMPLOYEES E
   UNION
   SELECT JH.EMPLOYEE_ID, E.FIRST_NAME, JH.START_DATE, JH.END_DATE
   FROM JOB_HISTORY JH, EMPLOYEES E
   WHERE E.EMPLOYEE_ID = JH.EMPLOYEE_ID
     )
     SELECT EMP_ID ,FIRST_NAME , START_DATE, 
     CASE
        WHEN END_DATE IS NULL THEN '재직중'
        ELSE    TO_CHAR(END_DATE)
        END AS "현재근무/사퇴날짜"
     FROM ABC;
   과정6) 부서명을 추가시키기, ABC안에 DEPARTMENT_ID를 추가시켜야 조인을 할 수 있다. 
   UNION을 기준으로 위에는 현재자료/ 아래는 JOB_HISTROY 과거의 자료 
   
           WITH ABC( EMP_ID ,FIRST_NAME , START_DATE, END_DATE,DEPARTMENT_ID)
   AS 
    (
     SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.HIRE_DATE, NULL, E.DEPARTMENT_ID
   FROM EMPLOYEES E
   UNION
   SELECT JH.EMPLOYEE_ID, E.FIRST_NAME, JH.START_DATE, JH.END_DATE, JH.DEPARTMENT_ID
   FROM JOB_HISTORY JH, EMPLOYEES E
   WHERE E.EMPLOYEE_ID = JH.EMPLOYEE_ID
     )
     SELECT EMP_ID ,FIRST_NAME , START_DATE, 
     CASE
        WHEN END_DATE IS NULL THEN '재직중'
        ELSE    TO_CHAR(END_DATE)
       END "현재근무/사퇴날짜"  ,
       D.DEPARTMENT_NAME
       
     FROM ABC A , DEPARTMENTS D
     WHERE A.DEPARTMENT_ID = D.DEPARTMENT_ID
     ORDER BY A.EMP_ID, START_DATE;
   
   
9) 직원의 업무시작날자 종료일, 부서명 출력
--job_history에서 기본키가 2개가 있는데 사원번호+업무시작날짜
--1개만 기본키를 가질경우 job_history의 충돌이 발생할수 있다. 101번이 사원->팀장이 되었을경우 입력이 안된다.. 

ALTER SESSION SET NLS_DATE_FORMAT='YYYY/MM/DD HH24:MI:SS';
SELECT SYSDATE FROM DUAL;

   9-1) 시작일이 06년 03월인 직원의 정보 출력
   SELECT FIRST_NAME, START_DATE, END_DATE ,DEPARTMENT_NAME
   FROM EMPLOYEES E
   JOIN JOB_HISTORY H ON E.DEPARTMENT_ID = H.DEPARTMENT_ID
   JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = H.DEPARTMENT_ID
   WHERE H.START_DATE LIKE '2006/03%';
   
   9-2) 종료일이 07년 12월 31일인 직원의 정보 출력
   SELECT FIRST_NAME, START_DATE, END_DATE ,DEPARTMENT_NAME
   FROM EMPLOYEES E
   JOIN JOB_HISTORY H ON E.DEPARTMENT_ID = H.DEPARTMENT_ID
   JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = H.DEPARTMENT_ID
   WHERE H.END_DATE LIKE '2007/12/31 00:00:00';
   
   9-3) 근무지역이 영국
   SELECT FIRST_NAME, START_DATE, END_DATE ,DEPARTMENT_NAME, C.COUNTRY_NAME
   FROM EMPLOYEES E
   JOIN JOB_HISTORY H ON E.DEPARTMENT_ID = H.DEPARTMENT_ID
   JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = H.DEPARTMENT_ID
   JOIN LOCATIONS L ON L.LOCATION_ID = D.LOCATION_ID
   JOIN COUNTRIES C ON C.COUNTRY_ID = L.COUNTRY_ID
   WHERE C.COUNTRY_ID = 'UK';
   
10) 업무시작 일별,월별 인원수(*) (???)
SELECT COUNT(*),TO_CHAR(START_DATE,'YYYY'),TO_CHAR(START_DATE,'MM')
FROM JOB_HISTORY H
JOIN EMPLOYEES E ON E.EMPLOYEE_ID = H.EMPLOYEE_ID
WHERE START_DATE >='1999/01/01' AND START_DATE<'2020/12/31'
GROUP BY TO_CHAR(START_DATE,'YYYY'),TO_CHAR(START_DATE,'MM');


11) job_history 2건 이상이 등록된 직원(???)
SELECT JH.EMPLOYEE_ID,  E.FIRST_NAME || ' ' || E.LAST_NAME 직원명, COUNT(JH.EMPLOYEE_ID)
FROM EMPLOYEES E
JOIN JOB_HISTORY JH
ON E.EMPLOYEE_ID = JH.EMPLOYEE_ID
GROUP BY JH.EMPLOYEE_ID, E.FIRST_NAME || ' ' || E.LAST_NAME
HAVING COUNT(JH.EMPLOYEE_ID) >= 2;

SELECT EMPLOYEE_ID, COUNT(EMPLOYEE_ID)
FROM JOB_HISTORY
GROUP BY EMPLOYEE_ID
HAVING COUNT(EMPLOYEE_ID)>=2;

-------------------서브쿼리로 풀기
SELECT * 
    FROM EMPLOYEES
        WHERE EMPLOYEE_ID IN
            (
                SELECT EMPLOYEE_ID, COUNT(EMPLOYEE_ID)
                FROM JOB_HISTORY
                GROUP BY EMPLOYEE_ID
                HAVING COUNT(EMPLOYEE_ID) >=2
            );
----여기서 문제가 되는거는 서브쿼리에서는 SELECT 2개가 나오는데 위에 WHERE 에서는 1개만 조건을 걸었으니 오류 발생
SELECT * 
    FROM EMPLOYEES
        WHERE EMPLOYEE_ID IN
            (
                SELECT EMPLOYEE_ID
                FROM JOB_HISTORY
                GROUP BY EMPLOYEE_ID
                HAVING COUNT(EMPLOYEE_ID) >=2
            );
            
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, JH.EMPLOYEE_ID
FROM JOB_HISTORY JH, EMPLOYEES E
WHERE JH.EMPLOYEE_ID = E.EMPLOYEE_ID;
--JOB_HISTROY 를 세야하니깐 
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, COUNT(JH.EMPLOYEE_ID)
FROM JOB_HISTORY JH, EMPLOYEES E
WHERE JH.EMPLOYEE_ID = E.EMPLOYEE_ID
GROUP BY E.EMPLOYEE_ID, E.FIRST_NAME
HAVING COUNT(JH.EMPLOYEE_ID)>=2;


12) 최대 월급을 받는 사람의 이름과 최소 월급을 받는 사람의 이름
SELECT *
FROM 
(
SELECT *
FROM EMPLOYEES
ORDER BY SALARY ASC) 
WHERE SALARY IS NOT NULL AND ROWNUM=1

UNION

SELECT *
FROM 
(SELECT *
FROM EMPLOYEES
ORDER BY SALARY DESC)
WHERE SALARY IS NOT NULL AND ROWNUM=1;

--서브쿼리 이용방법 
SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY IN (
(SELECT MAX(SALARY) FROM EMPLOYEES),
(SELECT MIN(SALARY) FROM EMPLOYEES)
);
12-2) 각부서의 최대 월급자 이름 
SELECT D.DEPARTMENT_NAME, E.FIRST_NAME, SALARY
FROM DEPARTMENTS D JOIN EMPLOYEES E 
ON D.DEPARTMENT_ID = E.EMPLOYEE_ID;




13) daniel 과 같은 부서에 근무하는 사람들
SELECT employee_id
FROM EMPLOYEES
WHERE first_name = 'Daniel'; --109번

SELECT FIRST_NAME,JOB_ID,DEPARTMENT_ID
FROM (
SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 100
OR JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 109)
);


14) 'Bruce'가 속해있는 부서명
SELECT employee_id,DEPARTMENT_ID
FROM EMPLOYEES
WHERE first_name = 'Bruce'; 

SELECT FIRST_NAME,JOB_ID,DEPARTMENT_ID
FROM (
SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60
OR JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 104)
);



