1. 엔티티: 상품과 멤버 -> 행위테이블 ORDERS    -> 제1정규화와 제2정규화
2. 1:N방식의 JOIN  || N:M 방식의 인라인 쿼리 || 테이블 3개의 JOIN (LEFT JOIN)
3. 제1~제3 정규화의 개념(필기0615참조) 프로시저,함수의 기본기본기본 개념 


CREATE TABLE PRODUCTS
(
    PR_ID CHAR(4) NOT NULL,  --상품 ID
    PR_NAME VARCHAR2(20) NOT NULL, --상품 이름
    PR_PRICE NUMERIC(6,2) NOT NULL, --상품 가격
    PR_QTY NUMERIC(4) NOT NULL  --상품 개수
);
CREATE TABLE MEMBERS
(
    M_ID CHAR(4) NOT NULL, --고객 ID
    M_NAME VARCHAR(20) NOT NULL --고객 이름

);
CREATE TABLE ORDERS
(
    M_ID CHAR(4) NOT NULL, --고객 ID
    PR_ID CHAR(4) NOT NULL, -- 상품 ID
    O_ID NUMERIC(7) NOT NULL, -- 구매한 ID(별도의 상품별 구분)
    QTY NUMERIC(7) NOT NULL --수량
    --O_TIME DATE  이렇게 해서 구매ID,가격ID,시간을 복합키로 한다. 근데 이 방법은 속도가 매우 느려진다.
);
--
INSERT INTO PRODUCTS VALUES('P001','새우깡',300.399,30);
INSERT INTO PRODUCTS VALUES('P001','메로나',500,50);
--
INSERT INTO MEMBERS VALUES('M001','홍길동');
INSERT INTO MEMBERS VALUES('M002','전우치');
--
INSERT INTO ORDERS VALUES('M001','P001',1,5);
INSERT INTO ORDERS VALUES('M001','P002',2,7);
INSERT INTO ORDERS VALUES('M001','P001',3,3);
INSERT INTO ORDERS VALUES('M002','P002',4,8);

SELECT * FROM PRODUCTS;
SELECT * FROM MEMBERS;
COMMIT;

    SELECT T1.M_NAME, T3.PR_NAME, T3.PR_PRICE, T2.QTY, T3.PR_PRICE * T2.QTY AS TOTAL
    FROM MEMBERS T1, ORDERS T2, PRODUCTS T3 
	WHERE T1.M_ID = T2.M_ID
	AND T2.PR_ID = T3.PR_ID;
    

--1.학생
CREATE TABLE STUDENTS
(
    S_ID CHAR(4) NOT NULL PRIMARY KEY,
    S_NAME VARCHAR2(30) NOT NULL,
    S_AGE NUMERIC(3) NOT NULL,
    S_GEN CHAR(1) NOT NULL,
    S_DEPA VARCHAR2(50) NOT NULL
)
;
SELECT * FROM STUDENTS;
INSERT INTO STUDENTS VALUES ('S001','홍길동',22,'M','국어국문학과');
INSERT INTO STUDENTS VALUES ('S002','전우치',23,'M','수학과');
INSERT INTO STUDENTS VALUES ('S003','백설공주',22,'F','불문과');
INSERT INTO STUDENTS VALUES ('S004','신데렐라',28,'F','불문과');
COMMIT;

--2.과목 
CREATE TABLE SUBJECTS
(
    SU_ID CHAR(4) NOT NULL PRIMARY KEY,
    SU_NAME VARCHAR2(100) NOT NULL
);

SELECT * FROM SUBJECTS;
INSERT INTO SUBJECTS VALUES('SU01','국어');
INSERT INTO SUBJECTS VALUES('SU02','수학');
INSERT INTO SUBJECTS VALUES('SU03','영어');
INSERT INTO SUBJECTS VALUES('SU04','과학');

--3.시험
CREATE TABLE EXMAS
(
    E_ID CHAR(4) NOT NULL PRIMARY KEY,
    E_NAME VARCHAR2(100) NOT NULL,
    SU_ID CHAR(4) NOT NULL
);

SELECT * FROM EXMAS;

INSERT INTO EXMAS VALUES ('E001','국어중간고사','SU01');
INSERT INTO EXMAS VALUES ('E002','국어기말고사','SU01');
INSERT INTO EXMAS VALUES ('E003','수학중간고사','SU02');
INSERT INTO EXMAS VALUES ('E004','수학기말고사','SU02');
INSERT INTO EXMAS VALUES ('E005','영어중간고사','SU03');
INSERT INTO EXMAS VALUES ('E006','영어기말고사','SU03');
INSERT INTO EXMAS VALUES ('E007','과학중간고사','SU04');
INSERT INTO EXMAS VALUES ('E008','과학기말고사','SU04');

--5. 학생이 시험을 친다.   
CREATE TABLE RESULTS
(
    S_ID CHAR(4) NOT NULL,
    E_ID CHAR(4) NOT NULL,
    SEQ NUMERIC(6) NOT NULL,
    SCORE NUMERIC(7,3) NOT NULL,
    IN_DATE DATE NOT NULL
)
;

INSERT INTO RESULTS VALUES('S001','E001',1,90,'2020-06-10');
INSERT INTO RESULTS VALUES('S001','E002',2,82,'2020-11-10');
INSERT INTO RESULTS VALUES('S001','E003',3,67,'2020-06-10');
INSERT INTO RESULTS VALUES('S001','E004',4,79,'2020-11-10');
INSERT INTO RESULTS VALUES('S001','E005',5,90,'2020-06-10');
INSERT INTO RESULTS VALUES('S001','E006',6,71,'2020-11-10');
INSERT INTO RESULTS VALUES('S001','E007',7,88,'2020-06-10');
INSERT INTO RESULTS VALUES('S001','E008',8,51,'2020-11-10');

INSERT INTO RESULTS VALUES('S002','E001',9,80,'2020-06-10');
INSERT INTO RESULTS VALUES('S002','E002',10,92,'2020-11-10');
INSERT INTO RESULTS VALUES('S002','E003',11,57,'2020-06-10');
INSERT INTO RESULTS VALUES('S002','E004',12,69,'2020-11-10');
INSERT INTO RESULTS VALUES('S002','E005',13,77,'2020-06-10');
INSERT INTO RESULTS VALUES('S002','E006',14,61,'2020-11-10');
INSERT INTO RESULTS VALUES('S002','E007',15,58,'2020-06-10');
INSERT INTO RESULTS VALUES('S002','E008',16,81,'2020-11-10');

INSERT INTO RESULTS VALUES('S003','E001',17,60,'2020-06-10');
--INSERT INTO RESULTS VALUES('S003','E002',18,92,'2020-11-10');
INSERT INTO RESULTS VALUES('S003','E003',19,83,'2020-06-10');
INSERT INTO RESULTS VALUES('S003','E004',20,69,'2020-11-10');
INSERT INTO RESULTS VALUES('S003','E005',21,72,'2020-06-10');
INSERT INTO RESULTS VALUES('S003','E006',22,63,'2020-11-10');
INSERT INTO RESULTS VALUES('S003','E007',23,50,'2020-06-10');
--INSERT INTO RESULTS VALUES('S003','E008',24,81,'2020-11-10');

SELECT * FROM STUDENTS;
SELECT * FROM SUBJECTS;
SELECT * FROM EXMAS;
SELECT * FROM RESULTS;

--학생별 총점
SELECT S_ID, SUM(SCORE) FROM RESULTS
GROUP BY S_ID;
--학생(이름)별 총점 
SELECT t1.s_name,r1.S_ID, SUM(SCORE) FROM RESULTS r1, students t1
GROUP BY t1.s_name,r1.S_ID
order by s_id;

--시험친 학생의 각 과목별 점수 // where t1.s_id 와 t2.s_id와 대응하는 값을 출력하는데 대응하는 값이 없으면 no출력
SELECT T1.S_ID, T1.S_NAME, T2.SCORE FROM STUDENTS T1, RESULTS T2
WHERE T1.S_ID = T2.S_ID
;
--시험친 학생의 각 과목별 점수 //left join //  where t1.s_id 와 t2.s_id와 대응하는 값을 모두 출력
SELECT T1.S_ID, T1.S_NAME, T2.SCORE FROM STUDENTS T1, RESULTS T2
WHERE T1.S_ID = T2.S_ID(+)
;
--시험친 학생의 총점, 
SELECT T1.S_NAME, SUM(T2.SCORE) FROM STUDENTS T1, RESULTS T2
WHERE T1.S_ID = T2.S_ID(+)
GROUP BY T1.S_NAME
;

--학생별 총점을 구해라 from 은 이미 메모리상에 위치하기 때문에 이 문법이 가능함 
SELECT  (SELECT S_NAME FROM STUDENTS WHERE S_ID = T1.S_ID) AS S_NAME
, SUM(SCORE) FROM RESULTS T1
GROUP BY S_ID
;

--N:M방식에서는 이렇게밖에 안된다.(
SELECT (SELECT S_NAME FROM STUDENTS WHERE S_ID = T1.S_ID)
, T1.SCORE FROM RESULTS T1
WHERE T1.SCORE>80;


--동일인이 나올경우는어쩔꺼냐 ...

--평균 
SELECT T1.S_ID,T1.S_NAME, SUM(T2.SCORE),AVG (T2.SCORE) 
FROM STUDENTS T1, RESULTS T2
WHERE T1.S_ID = T2.S_ID
GROUP BY T1.S_ID,T1.S_NAME
;
    
--랭크 순서 하려면    //여기서부터 ㄱㄱㄱㄱ
SELECT * from
(
    SELECT T1.S_ID,T1.S_NAME, SUM(T2.SCORE) AS TOTAL 
    ,AVG (T2.SCORE) AS AVGE
    FROM STUDENTS T1, RESULTS T2
    WHERE T1.S_ID = T2.S_ID
    GROUP BY T1.S_ID,T1.S_NAME
) A
ORDER BY A.TOTAL
;

-- S001 대신 S_NAME 을 넣는 인라인 쿼리
SELECT T1.S_ID, T1.SCORE FROM RESULTS T1
WHERE SCORE> 80;


--1:N 방식 
SELECT * FROM STUDENTS S1, RESULTS T1 WHERE S1.S_ID = T1.S_ID;

--N:M방식에서는 이렇게밖에 안된다.
SELECT (SELECT S_NAME FROM STUDENTS WHERE S_ID = T1.S_ID)
, T1.SCORE FROM RESULTS T1
WHERE T1.SCORE>80;

SELECT T1.* FROM STUDENTS S1,RESULTS T1
WHERE S1.S_ID = T1.S_ID AND T1.SCORE>80;


--인라인 코딩 방식이고 아래에서 FROM 다음부터 T1이라는 메모리로 저장되고 T1.* 로 출력 
SELECT T1.* FROM
(
SELECT S_ID , SUM(SCORE) 
FROM RESULTS
GROUP BY S_ID
) T1
;

SELECT T2.S_NAME, T1.TOTAL FROM
(
SELECT S_ID , SUM(SCORE) AS TOTAL
FROM RESULTS
GROUP BY S_ID
) T1,STUDENTS T2
WHERE T1.S_ID = T2.S_ID
;

--TO_CHAR() , TO_CHAR(날짜,포맷) , TO_CHAR(날짜,'DAY');
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL;

SELECT TO_CHAR(1,'0000')FROM DUAL; --공백이있네.

SELECT 'P' || TO_CHAR(1,'0000')FROM DUAL;

SELECT 'P' || TRIM(TO_CHAR(1,'0000')) FROM DUAL;

SELECT TO_DATE('20200620','YYYYMMDD') FROM DUAL;

--시험을 치지않는 학생 LEFTJOIN을 해라
Q1.학생이 시험을 쳤는데 학생이 시험치지 않는 학생과, 과목명을 출력해라
--시험을 한번이라도 친 사람은 RESULTS 에 데이터가 있다.
Q2. 시험을 한번이라도 치지 않는 학생을 구해라
--LEFT JOIN 
SELECT * FROM STUDENTS;
--이게 LEFT JOIN이다...오른쪽에 (+)있는게..
SELECT * 
FROM STUDENTS T1, RESULTS T2
WHERE T1.S_ID = T2.S_ID(+); 

--NULL을 통해서 한번도 안친사람을 찾을수  있다.
SELECT * 
FROM STUDENTS T1, RESULTS T2
WHERE T1.S_ID = T2.S_ID(+)
AND T2.S_ID IS NULL; 

Q1.학생이 시험을 쳤는데 학생이 시험치지 않는 학생과, 과목명을 출력해라
1.먼저 학생 4명 시험종료 8 = 32개의 데이터가 있는데 INLINE테이블로 먼저 만들어야 한다. CROSS JOIN = 1번학생 8개 2번학생 8개 3번학생 8개 4번학생 8 개 쫙 
SELECT * FROM STUDENTS T1, EXMAS T2;

2.32-22 = 10 개를 구해야한다.

--이내용들이 메모리에 구성되어있다.
SELECT * FROM
(SELECT T1.S_ID,T2.E_ID FROM STUDENTS T1, EXMAS T2)
T3, RESULTS T4
WHERE T3.S_ID = T4.S_ID(+)
;

SELECT * FROM
(SELECT T1.S_ID,T2.E_ID FROM STUDENTS T1, EXMAS T2)
T3, RESULTS T4
WHERE T3.S_ID = T4.S_ID(+)
AND T3.E_ID = T4.E_ID(+)
AND T4.E_ID IS NULL
;








INNER JOIN 양쪽 테이블에 필드값이 존재해야 한다.
















