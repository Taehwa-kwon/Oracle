정규화란 관계형 데이터베이스를 형성시키는 데이터베이스를 설계할때 만드는 방법
제1정규화: 테이블을 어떠한 필드도 다른테이블에 종속되면 안된다. -> 국어 점수 영어 점수 수학 점수 합계 평균 같이 두면 안된다는 뜻 . 어떠한 값 하나 바꾸면 다른것도 바뀌는 것
제2정규화: 행위가 발생할때 ROW데이터가 생겨난다. 엔터티와 엔터티가 새로운 행위가 만들어진다. 고객이 상품을 산다. 산다는 행위는 고객과 1:N , 상품과 산다는 행위도 1:N 관계 
제3정규화: 역정규화 하는것. 

Q.학과별 인원
SELECT A.COM_VAL, A.COM_ID, COUNT(*) AS COUNT
FROM
(
SELECT *
FROM COMMONS_TBL
WHERE GRP_ID ='GRP002'
)A
,STUDENTS_TBL B
WHERE A.GRP_ID = B.STU_DEPT_GRP(+)
AND A.COM_ID = B.STU_DEPT
GROUP BY A.COM_VAL, A.COM_ID;

Q.홍길동01의 이름,학과,주소를 뽑아내기
SELECT A.STU_NAME, A.COM_VAL
FROM
(
SELECT *
FROM STUDENTS_TBL S1, COMMONS_TBL C1
WHERE S1.STU_DEPT = C1.COM_ID
AND S1.STU_ID = 'STU001'
AND C1.COM_LVL =2
)A


Q. 결과를 확인하는 방법은....아 띠방.. ㅡㅡ 모르겠다


--공통코드 테이블 2개로 구성
SELECT * FROM GRPCOMMONS_TBL;
SELECT * FROM COMMONS_TBL;

--2.학생
SELECT * FROM STUDENTS_TBL;

--3.시간표 
SELECT * FROM STUDENTS_TIME_TBL;

--4.교수
SELECT * FROM PROFESSORS_TBL;

--5.과목
SELECT * FROM SUBJECTS_TBL;

--6.시험을 친다.
SELECT * FROM SCORES_TBL;



Q.학과명 , 과목명, 교수명
    --오시발 내가 푼것 !!!!
SELECT A.COM_VAL, A.SUB_NAME, P.PRO_NAME FROM
(
SELECT * 
FROM COMMONS_TBL C1,SUBJECTS_TBL S1
WHERE C1.COM_ID = S1.DEPT_CODE(+) --학과를 뽑아낸다
AND C1.GRP_ID = S1.DEPT_GRP(+)
)A,
PROFESSORS_TBL P
WHERE A.DEPT_CODE = P.PRO_DEPT
;

    --재형이가 알려준것
  SELECT * 
FROM COMMONS_TBL C1,SUBJECTS_TBL S1
WHERE C1.COM_ID = S1.DEPT_CODE(+)
AND C1.GRP_ID = S1.DEPT_GRP(+);
AND C1.GRP_ID = 'GRP002';
AND C1.COM_LVL = 2;  

    ---내가 한것 결과는  ?? 이것..하  ㅡㅡ 
SELECT A.COM_VAL, A.SUB_NAME, P.PRO_NAME FROM
(
SELECT * 
FROM COMMONS_TBL C1,SUBJECTS_TBL S1
WHERE C1.COM_ID = S1.DEPT_CODE(+) --학과를 뽑아낸다
AND C1.GRP_ID = S1.DEPT_GRP(+)
AND C1.GRP_ID = 'GRP002'
AND C1.COM_LVL = 2
)A,
PROFESSORS_TBL P
WHERE A.DEPT_CODE = P.PRO_DEPT
;


    --선생님이 푼것
SELECT * FROM COMMONS_TBL WHERE GRP_ID = 'GRP002' AND COM_LVL = 2; --총학과 23개
SELECT * FROM SUBJECTS_TBL; --과목은 89개  여기안에 교수PRO_ID 도 있다.

과목이 엔터티, 과목에 공통코드가 있으니깐 과목쪽이 다가 된다. 

1.학과별 과목의 관게    학과 1 과목 N 
2.과목과 교수의 관계    과목이 1 교수N 
;

1단계
SELECT * 
FROM COMMONS_TBL T1, SUBJECTS_TBL T2
WHERE T1.GRP_ID = T2.DEPT_GRP
AND T1.COM_ID = T2.DEPT_CODE;

2단계
SELECT GRP_ID, COM_ID, COM_VAL, SUB_ID, SUB_NAME, PRO_ID 
FROM COMMONS_TBL T1, SUBJECTS_TBL T2   --1대 N관계 
WHERE T1.GRP_ID = T2.DEPT_GRP(+)            --LEFT JOIN은 학과는 있는데 과목이 없다.
AND T1.COM_ID = T2.DEPT_CODE(+)
AND T1.GRP_ID = 'GRP002' AND T1.COM_LVL=2;  --여기서는 NULL값이 있으니깐 90개

3단계
SELECT T1.GRP_ID, T1.COM_ID, T1.COM_VAL, 
        T2.SUB_ID, T2.SUB_NAME, T2.PRO_ID, T3.PRO_NAME
FROM COMMONS_TBL T1, SUBJECTS_TBL T2, PROFESSORS_TBL T3
WHERE T1.GRP_ID = T2.DEPT_GRP(+)            --LEFT JOIN은 학과는 있는데 과목이 없다.
AND T1.COM_ID = T2.DEPT_CODE(+)
AND T2.PRO_ID = T3.PRO_ID(+)        --ROW를 기준으로 보면 ..나옴 
AND T1.GRP_ID = 'GRP002' AND T1.COM_LVL=2;     --


Q. 교수중에 가장 많은 학점을 강의하고 있는 교수 
        --내가 푼것!!
SELECT P1.PRO_ID,SUM(S1.SUB_CREDIT) AS CREDIT , RANK() OVER(ORDER BY SUM(SUB_CREDIT) DESC) AS RNK
FROM SUBJECTS_TBL S1, PROFESSORS_TBL P1   --김교수 올해 강의 1번 했니??!!!-> 하면  교수님 이름을 포함한 정보가  SUBJECTS에 ROW가 쌓인다. 
WHERE s1.pro_id = P1.PRO_ID(+)
GROUP BY P1.PRO_ID
ORDER BY CREDIT DESC;


Q.학과별로 학생들의 신청 총 학점
--태화
1단계 학과와 학생들  뽑고
SELECT *
FROM COMMONS_TBL C1, STUDENTS_TBL S1
WHERE C1.COM_ID = S1.STU_DEPT 
AND C1.GRP_ID = 'GRP002'
AND C1.COM_LVL = 2;

2단계 학생이 과목을 신청하면 - > STUDENTS_TIME_TBL에 쌓인다

SELECT B.SUB_NAME,SUM(B.SUB_CREDIT),COUNT(A.COM_ID) 
FROM 
(
SELECT *
FROM COMMONS_TBL C1, STUDENTS_TBL S1
WHERE C1.COM_ID = S1.STU_DEPT(+)
AND C1.GRP_ID = S1.STU_DEPT_GRP(+)
AND C1.GRP_ID = 'GRP002'
AND C1.COM_LVL = 2
)
A,
(
SELECT *
FROM SUBJECTS_TBL S1, STUDENTS_TIME_TBL S2
WHERE S1.SUB_ID = S2.SUB_ID
)
B
WHERE A.STU_DEPT = B.DEPT_CODE
GROUP BY B.SUB_NAME
ORDER BY SUB_NAME ASC
;

--박가나
SELECT A.COM_VAL, NVL(B.STU_NAME, '<학과에 학생없음>') STU_NAME, 
        NVL(SUM(D.SUB_CREDIT), 0) SUB_CREDIT
FROM COMMONS_TBL A, STUDENTS_TBL B, STUDENTS_TIME_TBL C, SUBJECTS_TBL D
WHERE A.GRP_ID = 'GRP002' AND A.COM_LVL = 2
AND A.COM_ID = B.STU_DEPT(+)
AND B.STU_ID = C.STU_ID(+)
AND C.SUB_ID = D.SUB_ID(+)
GROUP BY A.COM_VAL, B.STU_NAME
ORDER BY A.COM_VAL, B.STU_NAME;

--박재영
SELECT T1.COM_VAL AS 학과이름, T2.HAP AS 총합
FROM
COMMONS_TBL T1,
(
SELECT T2.STU_DEPT, SUM(NVL(T3.SUB_CREDIT, 0)) AS HAP
FROM STUDENTS_TIME_TBL T1, STUDENTS_TBL T2, SUBJECTS_TBL T3
WHERE T1.STU_ID(+) = T2.STU_ID
AND T1.SUB_ID = T3.SUB_ID(+)
GROUP BY T2.STU_DEPT
) T2
WHERE T1.COM_ID = T2.STU_DEPT(+)
AND T1.GRP_ID = 'GRP002'
AND T1.COM_LVL = 2
ORDER BY HAP DESC NULLS LAST
;

--선생님 답안
SELECT * FROM COMMONS_TBL WHERE GRP_ID = 'GRP002' AND COM_LVL=2; --학과 
1. 학과별 학생을 찾아야한다. 둘의 관계는 학과 1 학생N 이 된다. 제3정규화가 따라간다. 조인을 걸면 행위가 아니니깐 학생수 만큼 출력될 것이다. 
SELECT T1.COM_ID, T1.COM_VAL, T2.STU_ID, T2.STU_NAME 
FROM COMMONS_TBL T1, STUDENTS_TBL T2
WHERE T1.COM_ID = T2.STU_DEPT  
AND T1.GRP_ID = T2.STU_DEPT_GRP
AND T1.GRP_ID = 'GRP002' AND COM_LVL=2
;
2.단계 몇번 수강신청을 했는지 
SELECT T1.COM_ID, T1.COM_VAL, T2.STU_ID, T2.STU_NAME, T3.SUB_ID
FROM COMMONS_TBL T1, STUDENTS_TBL T2, STUDENTS_TIME_TBL T3
WHERE T1.COM_ID = T2.STU_DEPT  
AND T1.GRP_ID = T2.STU_DEPT_GRP
AND T2.STU_ID = T3.STU_ID(+) --수강신청을 안한 학생을 보여준다. STUDENTS_TBL 테이블과 STUDENTS_TIME_TBL 과 비교해서 학생이 시험치면 시간표에 점수가 쌓이니깐 NULL을 찾으려면 
AND T1.GRP_ID = 'GRP002' AND COM_LVL=2
;
3단계 과목보여주기
SELECT T1.COM_ID, T1.COM_VAL,T4.SUB_NAME, T2.STU_ID, T2.STU_NAME, T3.SUB_ID, T4.SUB_CREDIT
FROM COMMONS_TBL T1, STUDENTS_TBL T2, STUDENTS_TIME_TBL T3, SUBJECTS_TBL T4
WHERE T1.COM_ID = T2.STU_DEPT  
AND T1.GRP_ID = T2.STU_DEPT_GRP
AND T2.STU_ID = T3.STU_ID (+)
AND T3.SUB_ID = T4.SUB_ID(+)
AND T1.GRP_ID = 'GRP002' AND COM_LVL=2
ORDER BY T1.COM_VAL
;

Q.학과별로 학생들의 신청 총 학점

오케이 시발 이해함
바바.. COMMONS_TBL이랑 STUDENTS_TBL는 현재 1:N 관계고 그 사용된 필드!! 는 N관계가 된다. 그래서 다음것과 연결해야 하는데 사용된 필드는 N 이니깐 
사용되지 않는 테이블의 필드명과 다음 테이블의 필드와 합쳐준다. 
STUDENTS_TBL 과 STUDENTS_TIME_TBL 과 비교했을때 STU_ID를 공통으로 연결해주고 다시 여기서 STUDENTS_TIME_TBL이 행위테이블이니깐 (+)레프트 조인이 쌉가능
다시 STUDENTS_TIME_TBL 과 SUBJECTS_TBL의 공통된게 SUB_ID 를 사용한다. 

4단계 인라인 이유는 이 전체를 GROUP BY 할수 없으니깐 학생1명이 학과2개에 못들어가니깐 
SELECT A.STU_ID, A.STU_NAME,MAX(A.COM_VAL) AS SUB_NAME ,SUM(A.SUB_CREDIT) AS SUB_CREDIT
FROM
(
SELECT T1.COM_ID, T1.COM_VAL,T4.SUB_NAME, T2.STU_ID, T2.STU_NAME, T3.SUB_ID, T4.SUB_CREDIT
FROM COMMONS_TBL T1, STUDENTS_TBL T2, STUDENTS_TIME_TBL T3, SUBJECTS_TBL T4
WHERE T1.COM_ID = T2.STU_DEPT  
AND T1.GRP_ID = T2.STU_DEPT_GRP

AND T2.STU_ID = T3.STU_ID (+)

AND T3.SUB_ID = T4.SUB_ID

AND T1.GRP_ID = 'GRP002' AND COM_LVL=2
ORDER BY T4.SUB_NAME
)
A
GROUP BY  A.STU_ID, A.STU_NAME
ORDER BY SUB_NAME ASC
;


--부산에 사는 학생들의 시험점수 총점
--내가한것 시발 ㅏㅐㅈㄷ가허ㅔㅐ하ㅓㅇ 나도 할줄안다.. ㅡㅡ 미쳤따 진짜
SELECT S1.STU_ID AS "학번", S1.STU_NAME AS "이름", SUM(S2.SCORE) AS "2018/1학기"
FROM  COMMONS_TBL C1, STUDENTS_TBL S1, SCORES_TBL S2
WHERE S1.STU_ADDR2 = C1.COM_ID
AND C1.GRP_ID = S1.STU_ADDR_GRP
AND C1.COM_ID = 'COM0002'

AND S1.STU_ID = S2.STU_ID(+)
AND S2.GUBUN = 2
GROUP BY S1.STU_ID, S1.STU_NAME 
ORDER BY S1.STU_ID
;


--선생님
1단계 ; 

SELECT * FROM STUDENTS_TBL
WHERE STU_ADDR_GRP = 'GRP001'
AND STU_ADDR2 = 'COM0002';

2단계;
SELECT T1.STU_ID, T1.STU_NAME, T2.SCORE  
FROM STUDENTS_TBL T1, SCORES_TBL T2

WHERE  T1.STU_ID = T2.STU_ID
AND STU_ADDR_GRP = 'GRP001'
AND STU_ADDR2 = 'COM0002'
AND T2.DO_YEAR = 2018 AND T2.SEMESTER = 1 AND T2.GUBUN = 1
; --5번 (STU017이 5번 나온다)

--검증확인
SELECT * FROM SCORES_TBL
WHERE STU_ID = 'STU017'; --5번 

--
SELECT T1.STU_ID, T1.STU_NAME, SUM(T2.SCORE )
FROM STUDENTS_TBL T1, SCORES_TBL T2

WHERE  T1.STU_ID = T2.STU_ID
AND STU_ADDR_GRP = 'GRP001'
AND STU_ADDR2 = 'COM0002'
AND T2.DO_YEAR = 2018 AND T2.SEMESTER = 1 AND T2.GUBUN = 1
GROUP BY T1.STU_ID, T1.STU_NAME
;  --48명

--다시 검증
SELECT * FROM STUDENTS_TBL
WHERE STU_ADDR2 = 'COM0002';  --51명

--마지막 51명 맞추기 근데 맞출려고 보니 AND에서 3명의 학생이 시험안쳤으니깐 행위테이블에 (+)붙여도  NULL이라서 안뜸
SELECT T1.STU_ID, T1.STU_NAME, SUM(T2.SCORE )
FROM STUDENTS_TBL T1, SCORES_TBL T2

WHERE  T1.STU_ID = T2.STU_ID(+)
AND STU_ADDR_GRP = 'GRP001'
AND STU_ADDR2 = 'COM0002'
AND T2.DO_YEAR = 2018 AND T2.SEMESTER = 1 AND T2.GUBUN = 1
GROUP BY T1.STU_ID, T1.STU_NAME
;  --48명

SELECT T1.STU_ID, T1.STU_NAME, SUM(T2.SCORE)
FROM STUDENTS_TBL T1,
(
SELECT * FROM SCORES_TBL
WHERE DO_YEAR = 2018 AND SEMESTER = 1 AND GUBUN = 1
)T2
WHERE  T1.STU_ID = T2.STU_ID(+)
AND STU_ADDR_GRP = 'GRP001'
AND STU_ADDR2 = 'COM0002'

GROUP BY T1.STU_ID, T1.STU_NAME
;  --51명


Q.지역별 학생들의 총점, 평균을 구하자;
--내가한것
SELECT C1.COM_VAL  ,SUM(S2.SCORE)
FROM  COMMONS_TBL C1,STUDENTS_TBL S1, SCORES_TBL S2
WHERE C1.GRP_ID  = S1.STU_ADDR_GRP
AND C1.COM_ID = S1.STU_ADDR2

AND S1.STU_ID = S2.STU_ID
GROUP BY C1.COM_VAL
;
--선생님

SELECT * FROM STUDENTS_TBL T1, COMMONS_TBL T2, SCORES_TBL T3
WHERE T1.STU_ADDR_GRP = T2.GRP_ID
AND T1.STU_ADDR2 = T2.COM_ID

AND T1.STU_ID = T3.STU_ID(+)

AND T2.GRP_ID = 'GRP001'; --961개

--검증
SELECT COUNT(*) FROM SCORES_TBL; --964개 나옴
SELECT * FROM SCORES_TBL; --964개

--41번이 삭제안됌.
SELECT STU_ID FROM SCORES_TBL
GROUP BY STU_ID
ORDER BY STU_ID
;
--41번이 살아있네?? 41번의 데이터는 없는데 시험결과가 있다.
SELECT * FROM
(
SELECT STU_ID FROM SCORES_TBL
GROUP BY STU_ID
ORDER BY STU_ID
)T1, STUDENTS_TBL T2
WHERE T1.STU_ID = T2.STU_ID(+)
AND T2.STU_ID IS NULL
;

SELECT *
FROM SCORES_TBL
WHERE STU_ID = 'STU041'; -- ??근데 시발 여기는 왜 10개가 나오냐 ? 41번이 ?? 3개가 차이나야 하는데 무슨 10개가 차이나면 ...

A. 선생님 결과 ; 
SELECT T2.COM_ID, T2.COM_VAL, NVL(SUM(T3.SCORE),0) AS TOTAL , ROUND(NVL(AVG(T3.SCORE),0),2) AS AVG
FROM STUDENTS_TBL T1, COMMONS_TBL T2, SCORES_TBL T3
WHERE T1.STU_ADDR_GRP = T2.GRP_ID
AND T1.STU_ADDR2 = T2.COM_ID

AND T1.STU_ID = T3.STU_ID(+)

AND T2.GRP_ID = 'GRP001'
GROUP BY T2.COM_ID, T2.COM_VAL; --961개 NULL 포함되어있지 않다.



Q.2018년 6월29일 시험을 친 학과;
--내가 한 것
SELECT C1.COM_VAL
FROM STUDENTS_TBL S1, COMMONS_TBL C1, SCORES_TBL S2
WHERE S1.STU_DEPT = C1.COM_ID
AND S2.STU_ID = S1.STU_ID
AND C1.GRP_ID = 'GRP002'
AND EXAM_DATE = '2018/06/29'
GROUP BY C1.COM_VAL
;

--선생님 
SELECT T2.EXAM_DATE, T3.COM_ID, T3.COM_VAL
FROM STUDENTS_TBL T1, SCORES_TBL T2, COMMONS_TBL T3
WHERE T1.STU_ID = T2.STU_ID
AND T1.STU_DEPT_GRP = T3.GRP_ID
AND T1.STU_DEPT = T3.COM_ID
AND T3.GRP_ID = 'GRP002' AND T3.COM_LVL = 2
AND TO_CHAR(EXAM_DATE,'YYYYMMDD')='20180629'
GROUP BY T2.EXAM_DATE, T3.COM_ID, T3.COM_VAL
;

Q. 학생,과목, 신청한 과목의 학과 근데 만약에 다른학과에서 해당 시험을 친경우는 
모든 학생이 수강신청한 내용;
SELECT T1.STU_ID, T2.SUB_ID, T3.COM_ID, T4.SUB_ID 
FROM STUDENTS_TBL T1, STUDENTS_TIME_TBL T2, COMMONS_TBL T3, SUBJECTS_TBL T4
WHERE T1.STU_ID = T2.STU_ID 
AND T1.STU_DEPT = T3.COM_ID
AND T2.SUB_ID = T4.SUB_ID
AND T3.GRP_ID = 'GRP002' 
AND T3.COM_LVL = 2
AND T2.SUB_ID != T4.SUB_ID
; 

SELECT *
FROM STUDENTS_TIME_TBL T1
WHERE NOT EXISTS
(SELECT 1 FROM SCORES_TBL WHERE STU_ID = T1.STU_ID AND SUB_ID = T1.SUB_ID);

SELECT *
FROM SCORES_TBL T1
WHERE NOT EXISTS
(SELECT 1 FROM STUDENTS_TIME_TBL WHERE STU_ID = T1.STU_ID AND SUB_ID = T1.SUB_ID); --STU_ID학생이 SUB_ID과목을 수강신청을 한적이 없는데 결과가 나옴 


DELETE FROM SCORES_TBL WHERE STU_ID = 'STU044' AND SUB_ID = 'SUB0084'
;

Q.각 요일별 몇과목 시험 쳤을까?
월 : 5  
화 : 7과목
--내가한거는 아니지만 SUBJECTS 도필요한것 같음
SELECT STU_ID,TO_CHAR(S1.EXAM_DATE,'D') AS NUM, TO_CHAR(S1.EXAM_DATE,'DAY')AS DAY , COUNT(*)
FROM SCORES_TBL S1, SUBJECTS_TBL S2
WHERE S1.SUB_ID = S2.SUB_ID
GROUP BY STU_ID,TO_CHAR(S1.EXAM_DATE,'D'),TO_CHAR(S1.EXAM_DATE,'DAY')
;

--선생님
SELECT WK, COUNT(SUB_ID)
FROM
(
SELECT TO_CHAR(EXAM_DATE, 'DAY') AS WK , SUB_ID
FROM SCORES_TBL
)
GROUP BY  WK;
--힘들다...
SELECT -- TO_CHAR(EXAM_DATE,'YYYY-MM-DD'), 
TO_CHAR(EXAM_DATE, 'DAY') AS WK, 
DECODE(TO_CHAR(EXAM_DATE,'D'),'일요일',8,TO_CHAR(EXAM_DATE,'D')),
COUNT(SUB_ID)
FROM SCORES_TBL
GROUP BY  TO_CHAR(EXAM_DATE, 'DAY'), TO_CHAR(EXAM_DATE,'D')
ORDER BY DECODE(TO_CHAR(EXAM_DATE,'D'),'일요일',8,TO_CHAR(EXAM_DATE,'D'))
;

SELECT TO_CHAR(T1.EXAM_DATE, 'DAY'), COUNT(DISTINCT(T1.SUB_ID)) 
FROM SCORES_TBL T1
GROUP BY TO_CHAR(EXAM_DATE, 'DAY'), TO_CHAR(T1.EXAM_DATE, 'D')
ORDER BY TO_CHAR(T1.EXAM_DATE, 'D'); --위에서 DECODE땡겨오기 


Q.각 구별로 학생수 (부산시 - 금정구  :0명
                        - 해운대구 :0명)
                경남 창원시 창원구 합포동 : 2                 
SELECT *
FROM COMMONS_TBL C1, COMMONS_TBL C2
WHERE C1.GRP_ID = C2.GRP_ID  --여기서는 ROOT 의 GRP_ID 1개가 - GRP_ID 0001인 48-1(자기자신)을 크로스 조인한다. 
;

SELECT *
FROM COMMONS_TBL C1, COMMONS_TBL C2
WHERE C1.GRP_ID = C2.GRP_ID AND C1.COM_ID = C2.PARENT_ID --C1이 최상단이 되고 C2가 최하단이 된다.
;

1단계
SELECT *
FROM COMMONS_TBL C1, COMMONS_TBL C2
WHERE C1.GRP_ID = C2.GRP_ID AND C1.COM_ID = C2.PARENT_ID
AND C2.GRP_ID = C3.GRP_ID AND C2.COM_ID = C3.PARENT_ID
AND C1.GRP_ID = 'GRP001';


2단계 
SELECT *
FROM COMMONS_TBL C1, COMMONS_TBL C2, COMMONS_TBL C3
WHERE C1.GRP_ID = C2.GRP_ID AND C1.COM_ID = C2.PARENT_ID
AND C2.GRP_ID = C3.GRP_ID AND C2.COM_ID = C3.PARENT_ID
AND C1.GRP_ID = 'GRP001';

3단계 
SELECT *
FROM COMMONS_TBL C1, COMMONS_TBL C2, COMMONS_TBL C3, COMMONS_TBL C4
WHERE C1.GRP_ID = C2.GRP_ID AND C1.COM_ID = C2.PARENT_ID
AND C2.GRP_ID = C3.GRP_ID AND C2.COM_ID = C3.PARENT_ID
AND C3.GRP_ID = C4.GRP_ID AND C3.COM_ID = C4.PARENT_ID
AND C1.GRP_ID = 'GRP001';

4단계 
SELECT C1.COM_VAL, C2.COM_VAL, C3.COM_VAL , C4.COM_VAL 
FROM COMMONS_TBL C1, COMMONS_TBL C2, COMMONS_TBL C3, COMMONS_TBL C4, STUDENTS_TBL S1
WHERE C1.GRP_ID = C2.GRP_ID AND C1.COM_ID = C2.PARENT_ID
AND C2.GRP_ID = C3.GRP_ID AND C2.COM_ID = C3.PARENT_ID
AND C3.GRP_ID = C4.GRP_ID AND C3.COM_ID = C4.PARENT_ID
AND C4.GRP_ID = S1.STU_ADDR_GRP AND C4.COM_ID = S1.STU_ADDR
AND C1.GRP_ID = 'GRP001'
GROUP BY C1.COM_VAL, C2.COM_VAL, C3.COM_VAL , C4.COM_VAL;

SELECT * 
FROM COMMONS_TBL C1, COMMONS_TBL C2 , COMMONS_TBL C3
WHERE C1.GRP_ID = C2.GRP_ID AND C1.PARENT_ID = C2.COM_ID
AND C2.GRP_ID = C3.GRP_ID AND C2.PARENT_ID =C3.COM_ID
AND C1.GRP_ID = 'GRP001'

;



고유빈
SELECT B.GEONAME, COUNT(*) AS CNT
FROM
(
SELECT DECODE(A.NAMES1, 'ROOT', '', A.NAMES1  || ' ' ) ||  A.NAMES2  || '시 ' ||  A.NAMES3  || ' ' ||  A.NAMES4 AS GEONAME
FROM
(
SELECT T1.STU_ID, T1.STU_NAME, T5.GRP_ID AS GI, T5.COM_VAL AS NAMES1, T4.COM_VAL AS NAMES2, T3.COM_VAL AS NAMES3, T2.COM_VAL AS NAMES4
FROM STUDENTS_TBL T1, COMMONS_TBL T2, COMMONS_TBL T3, COMMONS_TBL T4, COMMONS_TBL T5
WHERE T1.STU_ADDR_GRP = T2.GRP_ID
AND T1.STU_ADDR = T2.COM_ID
AND T2.GRP_ID = T3.GRP_ID
AND T2.PARENT_ID = T3.COM_ID
AND T3.GRP_ID = T4.GRP_ID
AND T3.PARENT_ID = T4.COM_ID
AND T4.PARENT_ID = T5.COM_ID(+)
--AND T5.GRP_ID = 'GRP001'
ORDER BY T1.STU_ID
)A
WHERE A.GI= 'GRP001'
) B
GROUP BY B.GEONAME
ORDER BY 1
;


SELECT *
FROM COMMONS_TBL C1, COMMONS_TBL C2, COMMONS_TBL C3, COMMONS_TBL C4, STUDENTS_TBL S1
WHERE C1.GRP_ID = C2.GRP_ID AND C1.COM_ID = C2.PARENT_ID;
AND C2.GRP_ID = C3.GRP_ID AND C2.COM_ID = C3.PARENT_ID
AND C3.GRP_ID = C4.GRP_ID AND C3.COM_ID = C4.PARENT_ID
AND C4.GRP_ID = S1.STU_ADDR_GRP AND C4.PARENT_ID = S1.STU_ADDR
AND C1.GRP_ID = 'GRP001';

